Tutorial at: https://www.hackerearth.com/practice/basic-programming/bit-manipulation/basics-of-bit-manipulation/tutorial/

Basic Applications:
	-> Operations with bits are used in data compression ()
	-> Exclusive-or encryption(an algorithm to encrypt data for safety issues) 
	-> Bitwise operation are faster and more closer to system. Sometimse they optimize a program significantly.
	
Bitwise Operations:
	1->  NOT( ~)   
	2-> AND( &)   
	3-> OR( | )  
	4-> XOR( ^ )
	5-> Left Shift ( << ): Shift some number of bits to left and appends then with 0s. Similar to multiplying  a number by of 2 power k.
	6-> Right Shift( >> ): Shifts some number of bits to right. Similar to dividing a number by 2power k.
	
Algorithms based on bitwise operations:

	##1-> How to check if a given number is power of 2.
		Implementation (without bitmap):
			bool isPowerOfTwo(int x)
			{
				if(x == 0)
					return false;
				else
				{
					while(x%2 == 0) x /= 2;
					return (x == 1);
				}
			}
		Implementation (with bitmap):
				bool isPowerOfTwo(int x)
				{
					// x will check if x==0 and !(x & (x-1)) will check if x is a power of 2 or not
					return (Xx&& !(x & (x - 1))) ;
				}
		Explanation: 
			n & (n-1) will be zero if n is power of two as there can be only one 1 in the number which is power of two.	
		
-------------------------------------------------------------------------------------

	##2-> Counting the number of ones in the binary representation of the given number.
		Implemetation (with bitmap):
			int count_one(int n)
			{
				while( n )
				{
					n = n&(n-1);
					count++;
				}
				return count;
			}
			
-------------------------------------------------------------------------------------

	##3-> Check id the ith  is set in the binary form of the given number
		Implementation (with bitmap):
			bool check(int N)
			{
				if( N & ()1 << i )
					return true;
				return false;
			}
		Explanation:
			(1 << i)	generates a number which has only one set bit and that is at ith position. So if ith bit of number is set then this will evaluate to number greater than 0 otherwise 0.
			
-------------------------------------------------------------------------------------

	##4->How to generate all the possible subsets of a set?
		Info:
			A big advantage of bit manipulation is that it can help to iterate over all the subsets of an N-element set. As we know then 2powerN subsets of any set with N elements. What if we represent each element in a subset with a bit. A bit can be either 0 or 1,thus we can use this to denote whether the corresponding element belongs to this given subset or not. So each bit pattern will represent a subset.
			
			Consider a set A of 3 elements.
			A = {a, b, c}
			Now we need 3 bits, one bit for each element, 1 represent that the corresponding element is present in the subset, whereas 0 represent the corresponding element is not in the subset. Let's write all the possible combination of these 3 bits.
			
			0 = (000) = {}
			1 = (001) = {c}
			2 = (010) = {b}
			3 = (011) = {bc}
			4 = (100) = {a}
			5 = (101) = {ac}
			6 = (110) = {ab}
			7 = (111) = {abc}
		Pseudo code:
			possibleSubsets(A, N):
				for i =0 to 2powerN:
					for j =0 to N:
						if jth bit is set in i:
							print A[J]
						print '\n'
						
		Implementation:
			void possibleSubsets(char A[], N)
			{
				for(int i=0; i< (1 << N); i++)
				{
					if(i & (1 << j))
						cout << A[j] << ' ';
					cout << endl;
				}
			}
		
------------------------------------------------------------------------------------

	##5-> Find the largest power of 2 (most significant bit in binary form) which is less than or equal to the given number N.
		Idea: Change all the bits which are at the right side of the most significant digit, to 1.
		Property: As we know that when all teh bits of a number are 1, then N must be equal to 2poweri -1. where i is the number of bits in N.
		-->Example: Let's say binary form of a N is {1111} which s equal to 15.
		15 = 2power4 -1. where 4 is the number of bits in N.
		This property can be used to find the largest power of 2 less than or equal to N. How?
		If we somehow, change all the bits which are at right side of the most significant bit of N to 1, then the number will become x+(x-1)=2*x-1, where x is the required answer.
		-->Example: Let's say N=21={10101}, here most significant bit is the 4th one.(counting from 0th digit) and so the answer should be 16.
		So lets change all the right side bits of the most significant bit to 1. Now the number changes to			{11111}=31=2*16-1= Y.
		Now the required answer is (Y+1)>>1 or (Y+1)/2.
		Now the question arises here is how can we changell right side bits of most significant bit to 1?
		Let's take the N as 16 bit integer and binary form of N is {1000000000000000}. Here we have to change all the right side bits to 1.
		Initially we will copy that most significant bit to its adjacent right side by:			N=N | (N>>1).
		 
		 ##Tricks with bits:
		 1. x ^ (x & (x-1)): Returns the rightmost 1 in binary representation of x.
		 2. x & (-x): Returns the rightmost 1 in binary representation of x.
		 3. x | (1 << n): Returns the number x with the nth bit set.
		 
##Compute xor from 1 to n:
	int computeXor(int n)
	{
		if(n%4 == 0)
			return n;
		if(n%4 == 1)
			rn 1;
		if(n%4 == 2)
			return n+1;
		else
			return 0;
	}
	
		Property:
			1. ( n + i )  = ( n ^ i ) + 2 * ( n & i )
			
##Equal sum and xor:
	(n + i) = n ^i. 	Find such i's. 0 <= i <= n.
	here (n & i) should be zero. So we have to find i's that unset all set bits of n. Total such combinations are 2power(count of unset bits in n).
	Implementation:
		int countValues(int n)
		{
			int unset_bits = 0;
			while(n)
			{
				if((n & i) == 0)
					unset_bits++;
				n = n>>1;
			}
			return 1 << unset_bits;
		}
		
## XOR of all subsets:
	We can do it in O(1) time. The answer is always 0 if the given set has more than one element. Answer is value of single element if the given set has single element.
	
##Convert binary code directly into integer:
	auto number = 0b011;

##Quicketst way to swap two numbers:
 	void swap(int a,int b)
 	{
 		a ^= b;
 		b ^= a;
 		a^= b;
 	}
 	
 ##Find most significant set bit in O(1).Below code is for 32 bit integer
 	int setBitNumber(int n)
 	{
 		n |= n>>1;
 		n |= n>>2;
 		n |= n>>4;
 		n |= n>>8;
 		n |= n>>16;
 		n = n+1;
 		return (n >> 1);
 	}
 	
 ##We can quickly check if bits in a number are in alternate patternlike 101010). We compute n^(n >> 1). If n has an alternate pattern, then n^(n >> 1) operation will produce a number having set bits only.
